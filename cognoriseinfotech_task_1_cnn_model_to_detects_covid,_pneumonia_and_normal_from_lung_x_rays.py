# -*- coding: utf-8 -*-
"""CognoRiseInfoTech:Task_1:CNN Model to Detects COVID, PNEUMONIA AND NORMAL From  Lung  X-Rays.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19V8km1tjkjKdrohoV8UuPFGSJguteAzp
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import os
import cv2
from sklearn.model_selection import train_test_split
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense,Conv2D, MaxPooling2D, Flatten, Dropout

os.listdir('/content/drive/MyDrive/Covid Detection')

len(os.listdir('/content/drive/MyDrive/Covid Detection'))

covid_path=os.listdir('/content/drive/MyDrive/Covid Detection/COVID')
covid_path

len(covid_path)

normal_path=os.listdir('/content/drive/MyDrive/Covid Detection/NORMAL')
normal_path

pneumonia_path=os.listdir('/content/drive/MyDrive/Covid Detection/PNEUMONIA')
pneumonia_path

len(pneumonia_path)

categories = ['COVID', 'PNEUMONIA', 'NORMAL']
dirpath = '/content/drive/MyDrive/Covid Detection'

flat_input=[] # List to store  image data
output_label=[] # List to store labels
for i in categories:
  path = os.path.join(dirpath,i) #Join each category folder to main directory
  for img in os.listdir(path):
    img_path = os.path.join(path, img) #To get full path of image
    img_arr = cv2.imread(img_path,0) #This flag(0) ensures that the image read as grayscale.
    if img_arr is None:
        continue  # Skip if image cannot be read
    img_resize = cv2.resize(img_arr, (250, 250))  # Resize the image
    img_reshape = img_resize.reshape(250, 250, 1) # Reshape to include channel dimension
    flat_input.append(img_reshape)  # appends the reshaped image
    output_label.append(categories.index(i))  # Append the label
  print(f"Loaded completely {i}")

# Convert lists to numpy arrays
x = np.array(flat_input)
y = np.array(output_label)

len(x)

x.shape

len(y)

#x.reshape(-1, 150, 150, 1)  #By specifying -1, NumPy calculates the dimension size
                             #based on the total number of elements and the other specified dimensions.

y.shape

# Normalize pixel values
x = x / 255.0  # Normalize pixel values to [0, 1]
x

from tensorflow.keras.utils import to_categorical
# One-hot encode labels
y = to_categorical(y, num_classes=len(categories))

# Split the data into training and testing sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

from sklearn.metrics import accuracy_score
# Define the CNN model
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(250, 250, 1)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(64, (3, 3), activation='relu',input_shape=(250, 250, 1)),
    MaxPooling2D(pool_size=(2, 2)),
    Conv2D(128, (3, 3), activation='relu',input_shape=(250, 250, 1)),
    MaxPooling2D(pool_size=(2, 2)),
    Flatten(),
    Dense(12, activation='relu'),
    Dropout(0.5),
    Dense(len(categories), activation='softmax')])
model.compile(optimizer='adam',loss='categorical_crossentropy',metrics=['accuracy'])
Pred = model.fit(x_train,y_train,batch_size=32,epochs=30,validation_split=0.2)
Pred

model.evaluate(x_test, y_test)

plt.plot(Pred.history['accuracy'], label='accuracy')
plt.plot(Pred.history['val_accuracy'], label='val accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend(loc='lower right')
plt.show()

plt.plot(Pred.history['loss'],label ='Loss')
plt.plot(Pred.history['val_loss'], label='val loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(loc='lower right')
plt.show()

# Predicting on the 10th test sample
input_sample = x_test[10].reshape(1, 250, 250, 1)  # Ensure the sample is reshaped correctly
predicted_probabilities = model.predict(input_sample)  # Get the predicted probabilities
predicted_class = np.argmax(predicted_probabilities, axis=1)  # Convert probabilities to class label
predicted_category = categories[predicted_class[0]]  # Map the class label to the actual category
print(f"Predicted Category: {predicted_category}")  # Print the predicted category